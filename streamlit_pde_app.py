"""
streamlit_pde_app.py
====================

This Streamlit application demonstrates how to solve simple partial differential
equations using classical numerical methods.  It provides two modes:

1. **Heat Equation** â€“ solve a transient diffusion problem on a square grid
   with a configurable hotspot and view the evolution of the temperature field.
2. **Poisson Equation** â€“ solve a static Poisson problem with a point source
   at the centre of the domain and visualise the resulting potential.

The app uses the ``pde_solver`` module to perform the actual computations.
Users can adjust grid size, number of time steps and other parameters through
the sidebar controls.  Results are displayed using Plotly heatmaps.

To run the app locally, execute::

    streamlit run streamlit_pde_app.py

This script is independent of any Field of Truth or vQbit constructs and
illustrates how real PDEs can be solved interactively.
"""

import streamlit as st
import numpy as np
import plotly.express as px

from pde_solver import solve_heat_equation, solve_poisson_equation


def main() -> None:
    st.set_page_config(
        page_title="PDE Solver Demo",
        page_icon="ðŸ”¬",
        layout="wide",
    )
    st.title("ðŸ”¬ PDE Solver Demonstration")
    st.write(
        """
        This application demonstrates how to solve basic partial differential
        equations using finiteâ€‘difference methods.  Select the equation you wish
        to solve from the sidebar, configure the parameters, and then run the
        computation to view the resulting fields.  The heat equation shows the
        evolution of a temperature field over time, while the Poisson equation
        displays the potential generated by a point source.
        """
    )

    # Sidebar controls
    st.sidebar.header("âš™ï¸ Parameters")
    equation = st.sidebar.selectbox("Choose a PDE", ["Heat Equation", "Poisson Equation"])

    if equation == "Heat Equation":
        run_heat_equation()
    elif equation == "Poisson Equation":
        run_poisson_equation()


def run_heat_equation() -> None:
    """Run and display the heat equation solver."""
    st.header("ðŸ”¥ Heat Equation")
    st.write(
        """
        The 2D heat equation models diffusion of heat in a homogeneous medium.
        We solve it on a square domain using an explicit finiteâ€‘difference
        scheme with homogeneous Dirichlet boundary conditions.
        """
    )

    # Parameters
    grid_size = st.sidebar.slider("Grid size (NÃ—N)", min_value=30, max_value=100, value=50, step=10)
    steps = st.sidebar.slider("Number of time steps", min_value=10, max_value=500, value=100, step=10)
    diffusion_coeff = st.sidebar.number_input("Diffusion coefficient Î±", min_value=0.1, max_value=5.0, value=1.0, step=0.1)
    snapshot_interval = st.sidebar.slider("Snapshot interval", min_value=1, max_value=steps, value=max(steps // 5, 1))

    # Domain and initial condition
    N = grid_size
    dx = 1.0 / (N - 1)
    # Setup initial temperature with a hotspot
    u0 = np.zeros((N, N))
    radius = N // 10
    centre = N // 2
    u0[centre - radius : centre + radius, centre - radius : centre + radius] = 1.0

    # Choose time step to satisfy stability condition
    dt_max = 0.25 * dx * dx / diffusion_coeff
    dt = 0.5 * dt_max  # use half of maximum allowed dt for safety

    if st.sidebar.button("Run Heat Solver"):
        with st.spinner("Computing heat equation solutionâ€¦"):
            final, snapshots = solve_heat_equation(
                initial=u0,
                diffusion_coeff=diffusion_coeff,
                dx=dx,
                dt=dt,
                steps=steps,
                snapshot_interval=snapshot_interval,
            )

        # Display final result
        st.subheader("Final temperature distribution")
        fig_final = px.imshow(
            final,
            origin="lower",
            zmin=0,
            zmax=1,
            color_continuous_scale="hot",
            title="Temperature at final time",
        )
        st.plotly_chart(fig_final, use_container_width=True)

        # Display intermediate snapshots if available
        if snapshots:
            st.subheader("Intermediate snapshots")
            for idx, snap in enumerate(snapshots, start=1):
                fig_snap = px.imshow(
                    snap,
                    origin="lower",
                    zmin=0,
                    zmax=1,
                    color_continuous_scale="hot",
                    title=f"Snapshot after {snapshot_interval * idx} steps",
                )
                st.plotly_chart(fig_snap, use_container_width=True)


def run_poisson_equation() -> None:
    """Run and display the Poisson equation solver."""
    st.header("âš¡ Poisson Equation")
    st.write(
        """
        The Poisson equation ``âˆ‡Â²Ï† = f`` models many physical systems, including
        electrostatics and incompressible fluid pressure.  Here we solve a
        2D Poisson equation with zero boundary conditions and a point source
        at the centre of the domain using the Jacobi iterative method.
        """
    )

    # Parameters
    grid_size = st.sidebar.slider("Grid size (NÃ—N)", min_value=30, max_value=200, value=100, step=10)
    max_iter = st.sidebar.slider("Maximum iterations", min_value=500, max_value=10000, value=3000, step=500)
    tolerance = st.sidebar.number_input("Tolerance", min_value=1e-8, max_value=1e-2, value=1e-6, step=1e-7, format="%e")

    N = grid_size
    dx = 1.0 / (N - 1)
    rhs = np.zeros((N, N))
    # Place a point source at the centre
    rhs[N // 2, N // 2] = 1.0

    if st.sidebar.button("Run Poisson Solver"):
        with st.spinner("Solving Poisson equationâ€¦"):
            phi = solve_poisson_equation(
                rhs=rhs * N * N,  # scale source strength with grid resolution
                dx=dx,
                max_iter=max_iter,
                tol=tolerance,
            )

        st.subheader("Solution to the Poisson equation")
        fig_phi = px.imshow(
            phi,
            origin="lower",
            color_continuous_scale="viridis",
            title="Poisson equation potential field",
        )
        st.plotly_chart(fig_phi, use_container_width=True)


if __name__ == "__main__":
    main()